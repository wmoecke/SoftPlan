## Solução: CalculadorComposicao
* Foi criada a classe `Composicao` que permite guardarmos os valores lidos do arquivo de entrada em um objeto que possui todos os campos necessários. Quase todos os campos dessa classe foram definidos com o atributo `final` uma vez que, em sua maioria, não pretendemos alterar seus valores depois de setados pelo seu construtor. Os campos receberam _getters_ para permitir posterior acesso a partir de métodos externos. Para os campos cujo valor se pretende alterar após a instanciação da classe, há _setters_ específicos. 
* A fim de facilitar o parsing do arquivo de entrada, foi importada a **API JSON.simple**, que pode ser baixada no seguinte [web site](http://code.google.com/p/json-simple/ "API JSON.simple no Google"). Essa API é bem pequena e provê muitas funcionalidades, sendo compatível com o padrão RFC 4627. Esta biblioteca dispõe de classes de objetos para retorno dos elementos lidos, que mapeiam diretamente para as classes `java.util.Map` e `java.util.List`.
* Foi feita uma separação entre o código auxiliar e o código principal da aplicação (`main()`). Assim sendo, os métodos que cuidam das funções internas para processamento da lógica do negócio, bem como demais funções auxiliares ficou todo na classe `Helpers`. Foi escolhido deixar os métodos `static`, pois assim não é necessário instanciar-se a classe `Helpers` a cada vez que se deseja utilizar de seus métodos.
* Muitas das funcionalidades da lógica escrita na classe `Helpers` empregam os métodos de `.stream()` para realizar operações como navegar pelas coleções, buscar um item, filtrar, totalizar e agrupar. Um grande esforço foi feito para reduzir ao máximo as iterações, buscando sempre pela otimização dos algoritmos. Isso posto, julgou-se necessário utilizar de uma função recursiva (`buscaInsumos()`), uma vez que é possível termos um item de composição sendo ele próprio, uma composição de outros itens, e assim por diante.
* Nos métodos de teste `testBuscaComposicao()`, `testBuscaInsumos()` e `testCriaComposicao()` da classe `Helpers`, encontrou-se alguma dificuldade na validação quando efetuando comparações entre dois objetos populados. Apesar de terem sido efetuados diversos testes em _debug_, sempre que se inspecionava as variáveis `result` e `expResult`, os objetos armazenados nestas eram iguais (tipo e conteúdo). Como não foi possível determinar-se a causa desse problema, e em função do prazo para entrega desta demanda, optou-se por comparar as saídas serializadas de ambos os objetos.
* Alguns métodos requerem entrada a partir de um arquivo externo (`entrada.json` e `insumosTeste.json`). Os mesmos foram também disponibilizados a fim de permitir a execução da aplicação/testes sem qualquer empecilho.
* Para a saída da aplicação, não foi levado em conta qualquer tipo de ordenação dos itens apresentados na console, uma vez que não foi notada qualquer ordem específica no modelo fornecido. Contudo, se for desejado é possível ordenar os itens, empregando-se o método `.sorted()`, como no exemplo:
```
    ArrayList<Composicao> ret;
    ret = (ArrayList<Composicao>) listaDesordenada.stream()
            .sorted(Comparator.comparingLong(Composicao::getCodigoComposicao))
            .collect(Collectors.toList());
    return ret;
```